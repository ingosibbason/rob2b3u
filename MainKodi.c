#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineTrackerLeft, sensorLineFollower)
#pragma config(Sensor, in2,    lineTrackerRight, sensorLineFollower)
#pragma config(Sensor, in3,    armEncoder,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  Button,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           armMotor,      tmotorVex269, openLoop)
#pragma config(Motor,  port7,           clawMotor,     tmotorVex269, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool correctItem = false;

void detectObject()
{
	if(SensorValue(sonarSensor) < 30)
	{
		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;

		while(SensorValue(sonarSensor) > 3)
		{
		  motor[rightMotor] = 35;
			motor[leftMotor]	= 35;
		}
	}
	if(SensorValue(sonarSensor) > 3)
	{
		motor[rightMotor] = 0;
		motor[leftMotor] = 0;

	}
}

void driveTowardsObject()
{
		nMotorEncoder[rightMotor] = 0;
		nMotorEncoder[leftMotor] = 0;
		//nMotorEncoder[rightMotor] and nMotorEncoder[leftMotor] need to be calculated the correct length;
		while(nMotorEncoder[rightMotor] <= 2 && nMotorEncoder[leftMotor] <= 2)
		{
		  motor[rightMotor] = 20;
			motor[leftMotor]	= 20;
		}
}

void driveBack()
{

}

void grabObject()
{
	  while(SensorValue(sonarSensor) < 12)
	  {
	    motor[rightMotor] = -50;
	    motor[leftMotor] = -50;
	  }

		while(SensorValue(armEncoder) > 2200)
		{
			motor[armMotor] = 63;
			motor[clawMotor] = 63;
		}
		motor[armMotor] = 0;
}


void detectColor()
{
		if(SensorValue(lineTrackerLeft) > 500 && SensorValue(lineTrackerRight) > 500)
		{
			correctItem = false;
			driveBack();
		}
		else
		{
			correctItem = true;
			grabObject();
		}

}



task main()
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;


	if(correctItem == false)
	{
		detectObject();
		detectColor();
	}
	else{}
}
